'use strict';Object.defineProperty(exports, "__esModule", { value: true });exports.runAndTransformResultsToJestFormat = exports.initialize = undefined;












var _expect = require('expect');
var _jestMessageUtil = require('jest-message-util');
var _jestSnapshot = require('jest-snapshot');
var _state = require('../state');
var _utils = require('../utils');
var _run = require('../run');var _run2 = _interopRequireDefault(_run);

var _index = require('../index');var _index2 = _interopRequireDefault(_index);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};} /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              */ // eslint-disable-next-line import/default
const initialize = exports.initialize = (_ref) =>



{let config = _ref.config,globalConfig = _ref.globalConfig,localRequire = _ref.localRequire,testPath = _ref.testPath;
  Object.assign(global, _index2.default);

  global.xit = global.it.skip;
  global.xtest = global.it.skip;
  global.xdescribe = global.describe.skip;
  global.fit = global.it.only;
  global.fdescribe = global.describe.only;

  (0, _state.addEventHandler)(eventHandler);

  // Jest tests snapshotSerializers in order preceding built-in serializers.
  // Therefore, add in reverse because the last added is the first tested.
  config.snapshotSerializers.
  concat().
  reverse().
  forEach(path => {
    (0, _jestSnapshot.addSerializer)(localRequire(path));
  });const

  expand = globalConfig.expand,updateSnapshot = globalConfig.updateSnapshot;
  const snapshotState = new _jestSnapshot.SnapshotState(testPath, { expand, updateSnapshot });
  (0, _expect.setState)({ snapshotState, testPath });

  // Return it back to the outer scope (test runner outside the VM).
  return { globals: _index2.default, snapshotState };
};

const runAndTransformResultsToJestFormat = exports.runAndTransformResultsToJestFormat = (() => {var _ref3 = _asyncToGenerator(function* (_ref2)







  {let config = _ref2.config,globalConfig = _ref2.globalConfig,testPath = _ref2.testPath;
    const result = yield (0, _run2.default)();

    let numFailingTests = 0;
    let numPassingTests = 0;
    let numPendingTests = 0;

    for (const testResult of result) {
      switch (testResult.status) {
        case 'fail':
          numFailingTests += 1;
          break;
        case 'pass':
          numPassingTests += 1;
          break;
        case 'skip':
          numPendingTests += 1;
          break;}

    }

    const assertionResults = result.map(function (testResult) {
      let status;
      switch (testResult.status) {
        case 'fail':
          status = 'failed';
          break;
        case 'pass':
          status = 'passed';
          break;
        case 'skip':
          status = 'pending';
          break;}


      const ancestorTitles = testResult.testPath.filter(
      function (name) {return name !== _state.ROOT_DESCRIBE_BLOCK_NAME;});

      const title = ancestorTitles.pop();

      // $FlowFixMe Types are slightly incompatible and need to be refactored
      return {
        ancestorTitles,
        duration: testResult.duration,
        failureMessages: testResult.errors,
        fullName: ancestorTitles.concat(title).join(' '),
        numPassingAsserts: 0,
        status,
        title: testResult.testPath[testResult.testPath.length - 1] };

    });

    const failureMessage = (0, _jestMessageUtil.formatResultsErrors)(
    assertionResults,
    config,
    globalConfig,
    testPath);


    return {
      console: null,
      displayName: config.displayName,
      failureMessage,
      leaks: false, // That's legacy code, just adding it so Flow is happy.
      numFailingTests,
      numPassingTests,
      numPendingTests,
      perfStats: {
        // populated outside
        end: 0,
        start: 0 },

      skipped: false,
      snapshot: {
        added: 0,
        fileDeleted: false,
        matched: 0,
        unchecked: 0,
        uncheckedKeys: [],
        unmatched: 0,
        updated: 0 },

      sourceMaps: {},
      testFilePath: testPath,
      testResults: assertionResults };

  });return function runAndTransformResultsToJestFormat(_x) {return _ref3.apply(this, arguments);};})();

const eventHandler = event => {
  switch (event.name) {
    case 'test_start':{
        (0, _expect.setState)({ currentTestName: (0, _utils.getTestID)(event.test) });
        break;
      }
    case 'test_success':
    case 'test_failure':{
        _addSuppressedErrors(event.test);
        _addExpectedAssertionErrors(event.test);
        break;
      }}

};

const _addExpectedAssertionErrors = test => {
  const failures = (0, _expect.extractExpectedAssertionsErrors)();
  const errors = failures.map(failure => failure.error);
  test.errors = test.errors.concat(errors);
};

// Get suppressed errors from ``jest-matchers`` that weren't throw during
// test execution and add them to the test result, potentially failing
// a passing test.
const _addSuppressedErrors = test => {var _getState =
  (0, _expect.getState)();const suppressedErrors = _getState.suppressedErrors;
  (0, _expect.setState)({ suppressedErrors: [] });
  if (suppressedErrors.length) {
    test.status = 'fail';
    test.errors = test.errors.concat(suppressedErrors);
  }
};