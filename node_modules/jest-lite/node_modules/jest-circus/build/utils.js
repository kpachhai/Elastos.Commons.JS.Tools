'use strict';Object.defineProperty(exports, "__esModule", { value: true });























const makeDescribe = exports.makeDescribe = (
name,
parent,
mode) =>
{
  if (parent && !mode) {
    // If not set explicitly, inherit from the parent describe.
    mode = parent.mode;
  }

  return {
    children: [],
    hooks: [],
    mode,
    name,
    parent,
    tests: [] };

}; /**
    * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    *
    * 
    */const makeTest = exports.makeTest = (fn, mode, name, parent) => {
  if (!fn) {
    mode = 'skip'; // skip test if no fn passed
  } else if (!mode) {
    // if not set explicitly, inherit from its parent describe
    mode = parent.mode;
  }

  return {
    duration: null,
    errors: [],
    fn,
    mode,
    name,
    parent,
    startedAt: null,
    status: null };

};

const getAllHooksForDescribe = exports.getAllHooksForDescribe =
describe =>
{
  const result = { afterAll: [], beforeAll: [] };

  for (const hook of describe.hooks) {
    switch (hook.type) {
      case 'beforeAll':
        result.beforeAll.push(hook);
        break;
      case 'afterAll':
        result.afterAll.push(hook);
        break;}

  }

  return result;
};

const getEachHooksForTest = exports.getEachHooksForTest =
test =>
{
  const result = { afterEach: [], beforeEach: [] };let
  block = test.parent;

  do {
    for (const hook of block.hooks) {
      switch (hook.type) {
        case 'beforeEach':
          // Before hooks are executed from top to bottom, the opposite of the
          // way we traversed it.
          result.beforeEach.unshift(hook);
          break;
        case 'afterEach':
          result.afterEach.push(hook);
          break;}

    }
  } while (block = block.parent);
  return result;
};

const _makeTimeoutMessage = (timeout, isHook) =>
new Error(
`Exceeded timeout of ${timeout}ms for a ${
isHook ? 'hook' : 'test'
}.\nUse jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.`);


// Global values can be overwritten by mocks or tests. We'll capture
// the original values in the variables before we require any files.
var _global = global;const setTimeout = _global.setTimeout,clearTimeout = _global.clearTimeout;

const callAsyncFn = exports.callAsyncFn = (
fn,
testContext, _ref) =>





{let isHook = _ref.isHook,test = _ref.test,timeout = _ref.timeout;
  let timeoutID;

  return new Promise((resolve, reject) => {
    timeoutID = setTimeout(
    () => reject(_makeTimeoutMessage(timeout, isHook)),
    timeout);


    // If this fn accepts `done` callback we return a promise that fullfills as
    // soon as `done` called.
    if (fn.length) {
      const done = reason =>
      reason ? reject(reason) : resolve();

      return fn.call(testContext, done);
    }

    let returnedValue;
    try {
      returnedValue = fn.call(testContext);
    } catch (error) {
      return reject(error);
    }

    // If it's a Promise, return it. Test for an object with a `then` function
    // to support custom Promise implementations.
    if (
    typeof returnedValue === 'object' &&
    returnedValue !== null &&
    typeof returnedValue.then === 'function')
    {
      return returnedValue.then(resolve, reject);
    }

    if (!isHook && returnedValue !== void 0) {
      return reject(
      new Error(
      `
      test functions can only return Promise or undefined.
      Returned value: ${String(returnedValue)}
      `));


    }

    // Otherwise this test is synchronous, and if it didn't throw it means
    // it passed.
    return resolve();
  }).
  then(() => {
    // If timeout is not cleared/unrefed the node process won't exit until
    // it's resolved.
    timeoutID.unref && timeoutID.unref();
    clearTimeout(timeoutID);
  }).
  catch(error => {
    timeoutID.unref && timeoutID.unref();
    clearTimeout(timeoutID);
    throw error;
  });
};

const getTestDuration = exports.getTestDuration = test => {const
  startedAt = test.startedAt;
  return startedAt ? Date.now() - startedAt : null;
};

const makeTestResults = exports.makeTestResults = describeBlock => {
  let testResults = [];
  for (const test of describeBlock.tests) {
    const testPath = [];
    let parent = test;
    do {
      testPath.unshift(parent.name);
    } while (parent = parent.parent);const

    status = test.status;

    if (!status) {
      throw new Error('Status should be present after tests are run.');
    }
    testResults.push({
      duration: test.duration,
      errors: test.errors.map(_formatError),
      status,
      testPath });

  }

  for (const child of describeBlock.children) {
    testResults = testResults.concat(makeTestResults(child));
  }

  return testResults;
};

// Return a string that identifies the test (concat of parent describe block
// names + test title)
const getTestID = exports.getTestID = test => {
  const titles = [];
  let parent = test;
  do {
    titles.unshift(parent.name);
  } while (parent = parent.parent);

  titles.shift(); // remove TOP_DESCRIBE_BLOCK_NAME
  return titles.join(' ');
};

const _formatError = error => {
  if (!error) {
    return 'NO ERROR MESSAGE OR STACK TRACE SPECIFIED';
  } else if (error.stack) {
    return error.stack;
  } else if (error.message) {
    return error.message;
  } else {
    return `${String(error)} thrown`;
  }
};