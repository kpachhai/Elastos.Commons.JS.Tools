'use strict';Object.defineProperty(exports, "__esModule", { value: true });
















var _state = require('./state');
var _utils = require('./utils');function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};} /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */const run = (() => {var _ref = _asyncToGenerator(function* () {var _getState =
    (0, _state.getState)();const rootDescribeBlock = _getState.rootDescribeBlock;
    (0, _state.dispatch)({ name: 'run_start' });
    yield _runTestsForDescribeBlock(rootDescribeBlock);
    (0, _state.dispatch)({ name: 'run_finish' });
    return (0, _utils.makeTestResults)((0, _state.getState)().rootDescribeBlock);
  });return function run() {return _ref.apply(this, arguments);};})();

const _runTestsForDescribeBlock = (() => {var _ref2 = _asyncToGenerator(function* (describeBlock) {
    (0, _state.dispatch)({ describeBlock, name: 'run_describe_start' });var _getAllHooksForDescri =
    (0, _utils.getAllHooksForDescribe)(describeBlock);const beforeAll = _getAllHooksForDescri.beforeAll,afterAll = _getAllHooksForDescri.afterAll;

    for (const hook of beforeAll) {
      _callHook(hook);
    }
    for (const test of describeBlock.tests) {
      yield _runTest(test);
    }
    for (const child of describeBlock.children) {
      yield _runTestsForDescribeBlock(child);
    }

    for (const hook of afterAll) {
      _callHook(hook);
    }
    (0, _state.dispatch)({ describeBlock, name: 'run_describe_finish' });
  });return function _runTestsForDescribeBlock(_x) {return _ref2.apply(this, arguments);};})();

const _runTest = (() => {var _ref3 = _asyncToGenerator(function* (test) {
    const testContext = Object.create(null);

    const isSkipped =
    test.mode === 'skip' ||
    (0, _state.getState)().hasFocusedTests && test.mode !== 'only';

    if (isSkipped) {
      (0, _state.dispatch)({ name: 'test_skip', test });
      return;
    }var _getEachHooksForTest =

    (0, _utils.getEachHooksForTest)(test);const afterEach = _getEachHooksForTest.afterEach,beforeEach = _getEachHooksForTest.beforeEach;

    for (const hook of beforeEach) {
      yield _callHook(hook, testContext);
    }

    yield _callTest(test, testContext);

    for (const hook of afterEach) {
      yield _callHook(hook, testContext);
    }
  });return function _runTest(_x2) {return _ref3.apply(this, arguments);};})();

const _callHook = (hook, testContext) => {
  (0, _state.dispatch)({ hook, name: 'hook_start' });var _getState2 =
  (0, _state.getState)();const timeout = _getState2.testTimeout;
  return (0, _utils.callAsyncFn)(hook.fn, testContext, { isHook: true, timeout }).
  then(() => (0, _state.dispatch)({ hook, name: 'hook_success' })).
  catch(error => (0, _state.dispatch)({ error, hook, name: 'hook_failure' }));
};

const _callTest = (() => {var _ref4 = _asyncToGenerator(function* (
  test,
  testContext)
  {
    (0, _state.dispatch)({ name: 'test_start', test });var _getState3 =
    (0, _state.getState)();const timeout = _getState3.testTimeout;

    if (!test.fn) {
      throw Error(`Tests with no 'fn' should have 'mode' set to 'skipped'`);
    }

    return (0, _utils.callAsyncFn)(test.fn, testContext, { isHook: false, timeout }).
    then(function () {return (0, _state.dispatch)({ name: 'test_success', test });}).
    catch(function (error) {return (0, _state.dispatch)({ error, name: 'test_failure', test });});
  });return function _callTest(_x3, _x4) {return _ref4.apply(this, arguments);};})();exports.default =

run;